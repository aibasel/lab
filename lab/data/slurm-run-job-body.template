function print {
    local msg=${1}
    printf "[Slurm task %%05d] %%s\n" "$SLURM_ARRAY_TASK_ID" "$msg"
}

function print_run_dir {
    local run_id=${1}
    let "lower=((run_id - 1) / 100) * 100 + 1"
    let "upper=((run_id + 100 - 1) / 100) * 100"
    printf "runs-%%05d-%%05d/%%05d" $lower $upper $run_id
}

function execute_run {
    if [[ -f driver.log ]]; then
        echo "The run in $(pwd) has already been started --> skip it"
        return
    fi

    (
    "%(python)s" run
    RETCODE=$?
    if [[ $RETCODE != 0 ]]; then
        >&2 echo "The run script finished with exit code $RETCODE"
    fi
    ) > driver.log 2> driver.err

    # Delete empty driver.err files. driver.log always has content (for started runs).
    if [[ ! -s driver.err ]]; then
        rm driver.err
    fi
}

# Shuffle runs to avoid systematic bias.
declare -a SHUFFLED_RUN_IDS=(%(run_order)s)
NUM_RUNS=%(num_runs)d
RUNS_PER_TASK=%(runs_per_task)d

# Compute which indices belong to the Slurm task.
let "START_INDEX=($SLURM_ARRAY_TASK_ID - 1) * RUNS_PER_TASK"
let "END_INDEX=START_INDEX + RUNS_PER_TASK - 1"

if [ $END_INDEX -ge $NUM_RUNS ]; then
    let "END_INDEX=$NUM_RUNS - 1"
fi

# Execute runs.
for index in $(seq $START_INDEX $END_INDEX); do
    run_id=${SHUFFLED_RUN_IDS[$index]}
    run_dir=$(print_run_dir ${run_id})
    (cd "%(exp_path)s/$run_dir" && execute_run ${run_id})
done
